<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>（译）Haskell中的WHNF | 顾小骨的blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="在学习《real world Haskell》时对NF、WHNF的概念有些困惑，于是去stackoverflow查了查。本文来源于stackoverflow上的一个提问，大意就是怎么理解Haskell中的WHNF、HNF以及NF。译文是该提问下票数最高的回答。">
<meta property="og:type" content="article">
<meta property="og:title" content="（译）Haskell中的WHNF">
<meta property="og:url" content="http://yoursite.com/2016/09/22/haskell_what_is_WHNF/index.html">
<meta property="og:site_name" content="顾小骨的blog">
<meta property="og:description" content="在学习《real world Haskell》时对NF、WHNF的概念有些困惑，于是去stackoverflow查了查。本文来源于stackoverflow上的一个提问，大意就是怎么理解Haskell中的WHNF、HNF以及NF。译文是该提问下票数最高的回答。">
<meta property="og:updated_time" content="2016-10-05T18:39:18.518Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="（译）Haskell中的WHNF">
<meta name="twitter:description" content="在学习《real world Haskell》时对NF、WHNF的概念有些困惑，于是去stackoverflow查了查。本文来源于stackoverflow上的一个提问，大意就是怎么理解Haskell中的WHNF、HNF以及NF。译文是该提问下票数最高的回答。">
  
    <link rel="alternative" href="/atom.xml" title="顾小骨的blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/avatar.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">顾小骨</a></h1>
		</hgroup>

		
		<p class="header-subtitle">别想太多了，好好看书</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/随笔/">随笔</a></li>
				        
							<li><a href="/tags/haskell/">Haskell</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/guzheyuan" title="github">github</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/gu-xiao-gu-30-90" title="zhihu">zhihu</a>
					        
								<a class="mail" target="_blank" href="mailto:guzheyuan1991@163.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/haskell/" style="font-size: 20px;">haskell</a> <a href="/tags/leetcode/" style="font-size: 10px;">leetcode</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">毕业于上海大学-计算机工程与科学，目前在为手游做服务器端开发。会一点JavaScipt，正在学Haskell。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">顾小骨</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/avatar.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">顾小骨</h1>
			</hgroup>
			
			<p class="header-subtitle">别想太多了，好好看书</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔/">随笔</a></li>
		        
					<li><a href="/tags/haskell/">Haskell</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/guzheyuan" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/gu-xiao-gu-30-90" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="mailto:guzheyuan1991@163.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-haskell_what_is_WHNF" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/09/22/haskell_what_is_WHNF/" class="article-date">
  	<time datetime="2016-09-22T07:31:00.000Z" itemprop="datePublished">2016-09-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      （译）Haskell中的WHNF
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/haskell/">haskell</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在学习《real world Haskell》时对NF、WHNF的概念有些困惑，于是去stackoverflow查了查。本文来源于stackoverflow上的一个提问，大意就是怎么理解Haskell中的WHNF、HNF以及NF。译文是该提问下票数最高的回答。<br><a id="more"></a><br>原文地址：<a href="http://stackoverflow.com/questions/6872898/haskell-what-is-weak-head-normal-form" target="_blank" rel="external">链接</a></p>
<blockquote>
<p>I’ll try to give an explanation in simple terms. As others have pointed out, head normal form does not apply to Haskell, so I will not consider it here.</p>
</blockquote>
<p>我将试着用一些简单的术语来解释它们。另外，由于Haskell中并没有用到HNF，所以在这里我就不解释了。</p>
<h2 id="Normal-form"><a href="#Normal-form" class="headerlink" title="Normal form"></a>Normal form</h2><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><blockquote>
<p>An expression in normal form is fully evaluated, and no sub-expression could be evaluated any further (i.e. it contains no un-evaluated thunks).<br>These expressions are all in normal form:</p>
</blockquote>
<p>一个NF的表达式是可以完全被求值的，并且不存在需要进一步求值的子表达式（包括不可求值的部分）。<br>这些表达是都是NF的：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">42</span></div><div class="line">(<span class="number">2</span>, <span class="string">"hello"</span>)</div><div class="line">\x -&gt; (x + <span class="number">1</span>)</div></pre></td></tr></table></figure>
<blockquote>
<p>These expressions are not in normal form:</p>
</blockquote>
<p>这些表达式都不是NF的：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> + <span class="number">2</span>                 <span class="comment">-- 我们可以把它求值为 3</span></div><div class="line">(\x -&gt; x + <span class="number">1</span>) <span class="number">2</span>       <span class="comment">-- 我们可以应用这个函数</span></div><div class="line"><span class="string">"he"</span> ++ <span class="string">"llo"</span>         <span class="comment">-- 我们可以应用 (++)</span></div><div class="line">(<span class="number">1</span> + <span class="number">1</span>, <span class="number">2</span> + <span class="number">2</span>)        <span class="comment">-- 我们可以对 1 + 1 以及 2 + 2求值</span></div></pre></td></tr></table></figure>
<h2 id="Weak-head-normal-form"><a href="#Weak-head-normal-form" class="headerlink" title="Weak head normal form"></a>Weak head normal form</h2><h2 id="弱头范式"><a href="#弱头范式" class="headerlink" title="弱头范式"></a>弱头范式</h2><blockquote>
<p>An expression in weak head normal form has been evaluated to the outermost data constructor or lambda abstraction (the <em>head</em>). Sub-expressions <em>may or may not have been evaluated</em>. Therefore, every normal form expression is also in weak head normal form, though the opposite does not hold in general.</p>
</blockquote>
<p>我们说一个表达式是WHNF（弱头范式）的，意味着它可以被求值为最外层的值构造器或匿名函数（lambda）抽象（所谓的头<em>head</em>）。子表达式或许不能被求值。因此，所有NF表达式都满足WHNF，尽管反对方一般不这么认为。</p>
<blockquote>
<p>To determine whether an expression is in weak head normal form, we only have to look at the outermost part of the expression. If it’s a data constructor or a lambda, it’s in weak head normal form. If it’s a function application, it’s not.</p>
</blockquote>
<p>判断一个表达式是否满足WHNF，我们只需要看最外层的表达式。如果是一个值构造器或一个匿名函数，那它就满足WHNF。如果是一个函数调用，那它就不是。</p>
<blockquote>
<p>These expressions are in weak head normal form:</p>
</blockquote>
<p>这些表达式是满足WHNF的：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span> + <span class="number">1</span>, <span class="number">2</span> + <span class="number">2</span>) <span class="comment">-- 最外层是一个值构造器 (,)</span></div><div class="line">\x -&gt; <span class="number">2</span> + <span class="number">2</span> <span class="comment">-- 最外层是一个匿名函数的抽象</span></div><div class="line">'h' : (<span class="string">"e"</span> ++ <span class="string">"llo"</span>) <span class="comment">-- 最外层是一个值构造器 (:)</span></div></pre></td></tr></table></figure>
<blockquote>
<p>As mentioned, all the normal form expressions listed above are also in weak head normal form.<br>These expressions are not in weak head normal form:</p>
</blockquote>
<p>就像之前所提到的，所有以上列出的NF表达式都是符合WHNF的。以下表达式不符合WHNF：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> + <span class="number">2</span> <span class="comment">-- 最外层是 (+) 函数的调用</span></div><div class="line">(\x -&gt; x + <span class="number">1</span>) <span class="number">2</span> <span class="comment">-- 最外层是匿名函数 (\x -&gt; x + 1) 的调用</span></div><div class="line"><span class="string">"he"</span> ++ <span class="string">"llo"</span> <span class="comment">-- 最外层是 (++) 函数的调用</span></div></pre></td></tr></table></figure>
<h2 id="Stack-overflows"><a href="#Stack-overflows" class="headerlink" title="Stack overflows"></a>Stack overflows</h2><h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><blockquote>
<p>Evaluating an expression to weak head normal form may require that other expressions be evaluated to WHNF first. For example, to evaluate 1 + (2 + 3) to WHNF, we first have to evaluate 2 + 3. If evaluating a single expression leads to too many of these nested evaluations, the result is a stack overflow.</p>
</blockquote>
<p>把一个表达式转换为WHNF可能需要先对其他表达式求值使其成为WHNF。举个栗子，把1+（2+3）转化为WHNF，我们首先必须要对2+3求值。如果一个表达式的求值需要对许多内嵌的（子表达式）求值，那么将会导致栈溢出。</p>
<blockquote>
<p>This happens when you build up a large expression that does not produce any data constructors or lambdas until a large part of it has been evaluated. These are often caused by this kind of usage of foldl:</p>
</blockquote>
<p>当你展开一个大型表达式时，不会打开任何值构造器或lambda表达式，直到它的其他部分都已被求值。foldl函数经常被这样使用：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="title">foldl</span> (+) <span class="number">0</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] </div><div class="line">= foldl (+) (<span class="number">0</span> + <span class="number">1</span>) [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] </div><div class="line">= foldl (+) ((<span class="number">0</span> + <span class="number">1</span>) + <span class="number">2</span>) [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] </div><div class="line">= foldl (+) (((<span class="number">0</span> + <span class="number">1</span>) + <span class="number">2</span>) + <span class="number">3</span>) [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] </div><div class="line">= foldl (+) ((((<span class="number">0</span> + <span class="number">1</span>) + <span class="number">2</span>) + <span class="number">3</span>) + <span class="number">4</span>) [<span class="number">5</span>, <span class="number">6</span>] </div><div class="line">= foldl (+) (((((<span class="number">0</span> + <span class="number">1</span>) + <span class="number">2</span>) + <span class="number">3</span>) + <span class="number">4</span>) + <span class="number">5</span>) [<span class="number">6</span>] </div><div class="line">= foldl (+) ((((((<span class="number">0</span> + <span class="number">1</span>) + <span class="number">2</span>) + <span class="number">3</span>) + <span class="number">4</span>) + <span class="number">5</span>) + <span class="number">6</span>) [] </div><div class="line">= (((((<span class="number">0</span> + <span class="number">1</span>) + <span class="number">2</span>) + <span class="number">3</span>) + <span class="number">4</span>) + <span class="number">5</span>) + <span class="number">6</span> </div><div class="line">= ((((<span class="number">1</span> + <span class="number">2</span>) + <span class="number">3</span>) + <span class="number">4</span>) + <span class="number">5</span>) + <span class="number">6</span> </div><div class="line">= (((<span class="number">3</span> + <span class="number">3</span>) + <span class="number">4</span>) + <span class="number">5</span>) + <span class="number">6</span> </div><div class="line">= ((<span class="number">6</span> + <span class="number">4</span>) + <span class="number">5</span>) + <span class="number">6</span> </div><div class="line">= (<span class="number">10</span> + <span class="number">5</span>) + <span class="number">6</span> </div><div class="line">= <span class="number">15</span> + <span class="number">6</span> </div><div class="line">= <span class="number">21</span></div></pre></td></tr></table></figure>
<blockquote>
<p>Notice how it has to go quite deep before it can get the expression into weak head normal form.</p>
</blockquote>
<p>我们注意到，在表达式转换为WHNF之前，它嵌套的非常之深。</p>
<blockquote>
<p>You may wonder, why does not Haskell reduce the inner expressions ahead of time? That is because of Haskell’s laziness. Since it cannot be assumed in general that every subexpression will be needed, expressions are evaluated from the outside in.</p>
</blockquote>
<p>你可能会奇怪，为什么Haskell不提前减少内嵌的表达式呢？因为Haskell是惰性的。一般情况下你并不能假定所有子表达式都需要被求值，表达式的求值是由外而内的。</p>
<blockquote>
<p>(GHC has a strictness analyzer that will detect some situations where a subexpression is always needed and it can then evaluate it ahead of time. This is only an optimization, however, and you should not rely on it to save you from overflows).</p>
</blockquote>
<p>（GHC有一个严格的分析，它会检测哪些子表达式是必需的，然后提前计算它。但那只是一个优化，你不应该指望它来保证你的代码免于栈溢出）</p>
<blockquote>
<p>This kind of expression, on the other hand, is completely safe:</p>
</blockquote>
<p>换句话说，这类表达式是完全安全的：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">List</span> a = <span class="type">Cons</span> a (<span class="type">List</span> <span class="title">a</span>) | <span class="type">Nil</span></span></div><div class="line"><span class="title">foldr</span> <span class="type">Cons</span> <span class="type">Nil</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line"> = <span class="type">Cons</span> <span class="number">1</span> (foldr <span class="type">Cons</span> <span class="type">Nil</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]) <span class="comment">-- Cons 是一个构造器, 停止。</span></div></pre></td></tr></table></figure>
<blockquote>
<p>To avoid building these large expressions when we know all the subexpressions will have to be evaluated, we want to force the inner parts to be evaluated ahead of time.</p>
</blockquote>
<p>为了避免构建这类巨大的表达式，当我们知道所有子表达式都将会被求值时，我们必须强制提前对内部进行求值。</p>
<h2 id="seq"><a href="#seq" class="headerlink" title="seq"></a>seq</h2><h2 id="seq函数"><a href="#seq函数" class="headerlink" title="seq函数"></a>seq函数</h2><blockquote>
<p><em>seq</em> is a special function that is used to force expressions to be evaluated. Its semantics are that <em>seq x y</em> means that whenever <em>y</em> is evaluated to weak head normal form, x is also evaluated to weak head normal form.It is among other places used in the definition of foldl’, the strict variant of foldl.</p>
</blockquote>
<p>seq是一个特殊的函数，它用来强制表达式提前被求值。seq x y意味着无论是否y能被求值为WHNF，x都会被转换为WHNF。它在其他地方被使用，例如在foldl’函数（foldl的一个变体）的定义中<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">foldl'</span> f a [] = a</div><div class="line"><span class="title">foldl'</span> f a (x:xs) = <span class="keyword">let</span> a' = f a x <span class="keyword">in</span> a' `seq` foldl' f a' xs</div></pre></td></tr></table></figure></p>
<h2 id="Each-iteration-of-foldl’"><a href="#Each-iteration-of-foldl’" class="headerlink" title="Each iteration of foldl’"></a>Each iteration of foldl’</h2><h2 id="foldl’-的每一次迭代"><a href="#foldl’-的每一次迭代" class="headerlink" title="foldl’ 的每一次迭代"></a>foldl’ 的每一次迭代</h2><p>forces the accumulator to WHNF. It therefore avoids building up a large expression, and it therefore avoids overflowing the stack.</p>
<p>强制把累加器转换为WHNF。因此它可以避免构建一个巨大的表达式，也因此避免了栈溢出。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">foldl' (+) 0 [1, 2, 3, 4, 5, 6] </div><div class="line"><span class="section">= foldl' (+) 1 [2, 3, 4, 5, 6] </span></div><div class="line"><span class="section">= foldl' (+) 3 [3, 4, 5, 6] </span></div><div class="line"><span class="section">= foldl' (+) 6 [4, 5, 6] </span></div><div class="line"><span class="section">= foldl' (+) 10 [5, 6] </span></div><div class="line"><span class="section">= foldl' (+) 15 [6] </span></div><div class="line"><span class="section">= foldl' (+) 21 [] </span></div><div class="line"><span class="section">= 21 -- 21 是一个值构造器, 停止.</span></div></pre></td></tr></table></figure>
<p>But as the example on HaskellWiki mentions, this does not save you in all cases, as the accumulator is only evaluated to WHNF. In the example, the accumulator is a tuple, so it will only force evaluation of the tuple constructor, and not acc or len.</p>
<p>但是Haskell维基中提到的一个例子，并不是所有情况都能由此解决，当累加器可以求值为WHNF时。比如在那个例子中，累加器是一个元组，因此，它只强制求值到元组的构造器，而不是其中的acc和len。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="title">f</span> (acc, len) x = (acc + x, len + <span class="number">1</span>)</div><div class="line"><span class="title">foldl'</span> f (<span class="number">0</span>, <span class="number">0</span>) [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"> = foldl' f (<span class="number">0</span> + <span class="number">1</span>, <span class="number">0</span> + <span class="number">1</span>) [<span class="number">2</span>, <span class="number">3</span>]</div><div class="line"> = foldl' f ((<span class="number">0</span> + <span class="number">1</span>) + <span class="number">2</span>, (<span class="number">0</span> + <span class="number">1</span>) + <span class="number">1</span>) [<span class="number">3</span>]</div><div class="line"> = foldl' f (((<span class="number">0</span> + <span class="number">1</span>) + <span class="number">2</span>) + <span class="number">3</span>, ((<span class="number">0</span> + <span class="number">1</span>) + <span class="number">1</span>) + <span class="number">1</span>) []</div><div class="line"> = (((<span class="number">0</span> + <span class="number">1</span>) + <span class="number">2</span>) + <span class="number">3</span>, ((<span class="number">0</span> + <span class="number">1</span>) + <span class="number">1</span>) + <span class="number">1</span>) <span class="comment">-- 元组的构造器, 停止.</span></div></pre></td></tr></table></figure>
<blockquote>
<p>To avoid this, we must make it so that evaluating the tuple constructor forces evaluation of acc<br> and len. We do this by using seq.</p>
</blockquote>
<p>为了避免这种情况，我们必须强制对元组构造器的求值，然后强制对acc和len求值。我们可以这样使用seq：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="title">f'</span> (acc, len) x = <span class="keyword">let</span> acc' = acc + x</div><div class="line">                      len' = len + <span class="number">1</span></div><div class="line">                  <span class="keyword">in</span>  acc' `seq` len' `seq` (acc', len')</div><div class="line"><span class="title">foldl'</span> f' (<span class="number">0</span>, <span class="number">0</span>) [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"> = foldl' f' (<span class="number">1</span>, <span class="number">1</span>) [<span class="number">2</span>, <span class="number">3</span>]</div><div class="line"> = foldl' f' (<span class="number">3</span>, <span class="number">2</span>) [<span class="number">3</span>]</div><div class="line"> = foldl' f' (<span class="number">6</span>, <span class="number">3</span>) []</div><div class="line"> = (<span class="number">6</span>, <span class="number">3</span>)                    <span class="comment">-- 元组构造器，停止.</span></div></pre></td></tr></table></figure>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/09/23/real_world_haskell_note_ch4/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          《Real World Haskell》 第四章读书笔记
        
      </div>
    </a>
  
  
    <a href="/2016/09/17/real_world_haskell_note_ch3/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">《Real World Haskell》 第三章读书笔记</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="haskell_what_is_WHNF" data-title="（译）Haskell中的WHNF" data-url="http://yoursite.com/2016/09/22/haskell_what_is_WHNF/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"guzheyuan"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 顾小骨
    	</div>
      	<div class="footer-right">
      		由 <a href="http://hexo.io/" target="_blank">Hexo</a> 强力驱动
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>